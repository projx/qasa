import requests
from lib.base import *


########################################################################################################################
## Config Model
## Uses pythantic to provide a typed-dict and validation

class QSplunkHECModel(QSenderModel):
    """
    Config attribs expected for Splunk HEC
    """
    url: str
    verify_ssl: bool = True
    index: str


########################################################################################################################
## Sender Model
##

class QSplunkHECSender(QSendConnector):
    """
    Splunk HEC Send Connector

    This takes the output generated by a Format Connector, sending it to Splunk to HEC
    """
    logger = False
    args = dict()

    def __init__(self, **args):
        self.args = QSplunkHECModel(**args)
        self.logger = logging.getLogger(self.args.alias)
        self.logger.setLevel(logging.INFO)

        hec_handler = SplunkHECHandler()
        hec_handler.setup(args)
        self.logger.addHandler(hec_handler)

        self.logger.propagate = False

    # @staticmethod
    # def get_config_attribs():
    #     return ["alias", "connector_class", "url", "auth_code", "verify_ssl", "index"]


    def prerequisites(self,  initiator):
        """
        Steps required to initiate a connection/query, for this particular class, the main requirement
        is to register and download the required MIBs
        """
        pass


class SplunkHECHandler(logging.Handler):

    def setup(self, args):
        self.url = args["url"]
        self.auth_code = args["auth_code"]
        self.verify_ssl = args["verify_ssl"]
        self.index = args["index"]


    def emit(self, record):
        """
        This is the method that is called when a log message is emitted, uses basic Request lib to send, might not be
        very optimal but it works.
        :param record:
        :return:
        """
        authHeader = {'Authorization': 'Splunk {}'.format(self.auth_code)}
        jsonDict = {"index": self.index, "event": record.msg }
        r = requests.post(self.url, headers=authHeader, json=jsonDict, verify=self.verify_ssl)
        return r.text
